## 次の式の値は何か。

    > (A 1 10)
    1024
    > (A 2 4)
    65536
    > (A 3 3)
    65536

## 次の手続きを考える。

**注意** 正の整数は 0 を含まない。

### 手続きf

    (define (f n) (A 0 n))

定義本体に置き換える。

    (cond ((= n 0) 0)
          ((= 0 0) (* 2 n))
          ((= n 1) 2)
          (else (A (- 0 1)
                   (A 0 (- n 1)))))

問題より n>0 であり、また2つめの条件が常にtrueなので、実質以下のようになる。

    (* 2 n)

つまり、(f n) は 2n を計算する。

### 手続きg

    (define (g n) (A 1 n))

定義本体に置き換える

    (cond ((= n 0) 0)
          ((= 1 0) (* 2 n))
          ((= n 1) 2)
          (else (A (- 1 1)
                   (A 1 (- n 1)))))

問題より n>0 であり、また2つめの条件が常にfalseなので、実質以下のようになる。

    (cond ((= n 1) 2)
          (else (A 0 (A 1 (- n 1)))))

else節は全体が手続きfの形であり、そのパラメタ部分は手続きgの形なので、以下のように置き直せる。

    (cond ((= n 1) 2)
          (else (* 2 (g (- n 1)))))

n は計算には用いられず、カウンタとして働くだけである。
else節に注目すると、これは n>=2 の場合に、(g 1) の値（すなわち 2）に n-1 回 2 を掛けるループであるので、数学的には 2 * 2^(n-1) 、つまり 2^n である。
これはelse節を評価しない n=1 の場合にも成り立つ。
よって、(g n) は 2^n を計算する。

### 手続きh

    (define (h n) (A 2 n))

定義本体に置き換える

    (cond ((= n 0) 0)
          ((= 2 0) (* 2 n))
          ((= n 1) 2)
          (else (A (- 2 1)
                   (A 2 (- n 1)))))

問題より n>0 であり、また2つめの条件が常にfalseなので、実質以下のようになる。

    (cond ((= n 1) 2)
          (else (A 1 (A 2 (- n 1)))))

else節は全体が手続きgの形であり、そのパラメタ部分は手続きhの形なので、以下のように置き直せる。

    (cond ((= n 1) 2)
          (else (g (h (- n 1)))))

ここでも n はカウンタである。
else節に注目すると、これは n>=2 の場合に、再帰的に 2^h(n-1) を計算する。

n=2 の場合

    (h 2)
    (g (h 1))
    (g 2)
    2^2 = 4

n=3 の場合

    (h 3)
    (g (h 2))
    (g 4)
    2^4 = 2^(2^2) = 16

n=4 の場合

    (h 4)
    (g (h 3))
    (g 16)
    2^16 = 2^(2^(2^2)) = 65536

n=5 の場合

    (h 5)
    (g (h 4))
    (g 65536)
    2^65536 = 2^(2^(2^(2^2))) = 巨大な数

これを数学的になんと表現できるのか分からない。。。

